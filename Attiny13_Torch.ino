/*
 ФОНАРЬ
 автор Илья Рязанов 22229999@mail.ru
 немного допилил Сергей Лебеденко
*/
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
// #include <avr/eeprom.h>
#include <avr/sleep.h>      // здесь описаны режимы сна

unsigned int t=0;

#define MOSFET_CH 1 // Тип мосфета: 0 - N-Channel, 1 - P-Channel
#define USE_BACK_LED 1 // Исспользовать "затылочный" светодиод: 0 - нет, 1 - да
#define USE_STARTUP_BLINK 1 // Моргать светодиодом при включении: 0 - нет, 1 - да

#define PORT PORTB
#define PIN PINB
#define LED0 PB0
#define LED1 PB3
#define KN0 PB1
#define KN1 PB5
// #define Najatie_1 (PIN&(1 << KN0))==0   // Если нажата 1
#define Najatie_1 PIN&(1 << KN0)   // Если нажата 1

#define PUSH_TIME 100 // задержка для обхода дребезга кнопки
#define NO_SWITCH_TIME 30000 // таймаут, после которого фонарик выключается, а не переключает яркость
#define TYPE_DIV 1 // тип делителя напряжения: 0 - 10/27, 1 - 22/68

volatile unsigned char w = 0;
volatile unsigned char Sleep = 1;
unsigned char countPush = 0;
volatile unsigned char lowBattary = 0;

volatile unsigned char buttonReleased = 0;
volatile unsigned char Mode = 2;
volatile unsigned long TimeTick = 0;
volatile unsigned long lastPushButton = 0;

volatile unsigned int  ACP_Schetchik = 0;
volatile unsigned long ACP_Summa = 0;

#if TYPE_DIV == 0
const unsigned char shiftPWM[] = {27, 128, 182};
#else
const unsigned char shiftPWM[] = {26, 86, 175};
#endif

// ФОНАРЬ

// Обработчик прерывания от интегрированного АЦП
ISR(ADC_vect) { 

	unsigned long ADCdata;  // Буферная переменная для. хранения
	ADCdata = ADCW;         // результата преобразования

  if( ACP_Schetchik >= 1023 ) { // програмка складывает 1024 значений измерений АЦП
                                // для вычисления среднего значения и исключения импульсних помех

    // ACP_Summa = ACP_Summa >> 10; // деление на 1024 :)
    /* нужен делитель 1/3 (10к/27к), чтобы ловить напряжение аккумулятора
      тогда формула рассчёта ACP = (int) 251.6 * V_in ( 10/(10+27)*1024/1.1 * V_in )
      при 4.2В ADC = 251.6 * 4.2 = 1056
      при 3.1В ADC = 251.6 * 3.1 = 780
      при 2.8В ADC = 251.6 * 2.8 = 704

      если делитель 22к/68к то ACP = (int) 227.5 * V_in:
      при 4.2В ADC = 227.5 * 4.2 = 956
      при 3.1В ADC = 227.5 * 3.1 = 705
      при 2.8В ADC = 227.5 * 2.8 = 637
    */

    #if TYPE_DIV == 0
    uint8_t t = (( ACP_Summa * 241 ) >> 20 ) - shiftPWM[w];

    if( ACP_Summa < 798720 ) { OCR0A = 245; lowBattary = 1; }  // 780*1024  если напряжение меньше 3.1V то уменьшаем яркость до минимума
    if( ACP_Summa < 720896 ) { Sleep = 1; }                    // 704*1024  если напряжение меньше 2,8V то уходим в спячку
    #else
    uint8_t t = ( ACP_Summa >> 12 ) - shiftPWM[w];

    if( ACP_Summa < 721920 ) { OCR0A = 245; lowBattary = 1; }  // 705*1024  если напряжение меньше 3.1V то уменьшаем яркость до минимума
    if( ACP_Summa < 652288 ) { Sleep = 1; }                    // 637*1024  если напряжение меньше 2,8V то уходим в спячку
    #endif
    
    if( lowBattary == 0 ) OCR0A = t; // если напряжение упало до минимума, то не корректировать яркость, иначе светодиод начнёт моргать
    ACP_Schetchik = 0;
    ACP_Summa = 0; 
  } else { 
    ACP_Schetchik++;
    ACP_Summa += ADCdata;
  }

  ADCSRA = ADCSRA | 0x40; // Устанавливаем разряд ADSC в регистре ADCSR, чтобы начать новое преобразование
}

//Обработака нажатия кнопки
SIGNAL(INT0_vect) {
  if( lastPushButton == 0 ) // Защита от дребезга, запоминаем "время" отпускания кнопки 
    lastPushButton = TimeTick;
}

// Просто таймер для отсчета времени после которого пелеключаем режим
ISR(TIM0_OVF_vect) {
  TimeTick++; 
}        

// подпрограмма включения любой ножки МК, лог 1
void pinON(const unsigned char t) {
	PORT |= _BV(t);
}

// подпрограмма выключения любой ножки МК, лог 0
void pinOFF(const unsigned char t) {
	PORT &= ~_BV(t);
}

#if USE_STARTUP_BLINK == 1
// моргнуть светодиодом
void blink() {
  #if USE_BACK_LED == 1
  pinON(LED1);
  _delay_ms(150);
  pinOFF(LED1); // (зажигаем и гасим светодиод).
  #else
    #if MOSFET_CH == 1
    pinOFF(LED0);
    _delay_ms(50);
    pinON(LED0);
    #else
    pinON(LED0);
    _delay_ms(50);
    pinOFF(LED0);
    #endif
  #endif
}
#endif

int main(void) {

  DDRB |= ((1 << LED0)|(1 << LED1));// выходы
  PORT |= (1 << KN0); // подключаем подтягивающие резисторы

#if USE_STARTUP_BLINK == 1
  #if MOSFET_CH == 1
  pinON(LED0);
  #endif

  // два раза мигнуть после подключения аккумулятора
  blink();
  _delay_ms(500);
  blink();
#endif

  /*
  Это делается с помощью битов CS02 CS01 CS00 регистра TCCR0B.
  CS02 | CS01 | CS00
  0 | 0 | 0 - таймер/счетчик остановлен
  0 | 0 | 1 - нет предделителя *
  0 | 1 | 0 - предделитель 8 **
  0 | 1 | 1 - предделитель 64 **
  1 | 0 | 0 - предделитель 256 **
  1 | 0 | 1 - предделитель 1024 **
  */

#if MOSFET_CH == 0
  TCCR0A = 0b11000001;  // управление выходом, ШИМ (только шим) Для N-канальлного транзистора
#else
  TCCR0A = 0b10000001;  // ИНВЕРСНЫЙ режим управление выходом, ШИМ, Для Р-канального транзистора
#endif

  TCCR0B = 0b00000001;  // делитель N = 1   (только шим) Таблица выше
  
  //  OCR0A = 128;   // Значение регистра определяет яркость светодиода
  OCR0A = 241; // расчёт реальной яркости начнётся через 1024 отсчёта ADC, по этому начинать с минимальной яркости

  /////////////////////////////////////////////////////////////////////////////////////////////
  // Инициализация прерываний по INT0
  GIMSK = 0b01000000; // Разрешение прерываний INT0 на входе PB1
  MCUCR = 0b00000000; // при перепаде низком уровне на PB1

  //////////////////////////////////////////////////////////////////////////////////////////////
  set_sleep_mode (SLEEP_MODE_PWR_DOWN); //определяем какой режим сна будет

                      /* Инициализации таймера/счётчика */
                          // Нормальная работа счётчика
  //TCNT0   = 139;        // настройка таймера счетчика
  TIMSK0 |= 1<<TOIE0;     // Разрешение прерываний по переполнению

  ADMUX  = 0b01000010;    // Назначаем в качестве аналогового входа РB4 ; 
  ADCSRA = 0b11001110;    // 0b11001110 - активизируем АЦП с коэффициентом деления 128, 
                          // разрешаем прерывание от АЦП и начинаем преобразование

  sei(); // Общее разрешение прерываний

  while(1) {

    // Mode - Режим
    // 0 - переключаем уровни
    // 1 - выключаем
    // 2 - не меняем уровень

    // программа изменена, переключение идет вверх и 3 режима


    if( lastPushButton > 0 && TimeTick - lastPushButton > PUSH_TIME ) {
      buttonReleased = Najatie_1;
    }

    if( buttonReleased > 0 ) {

      pinON(LED1);      // включаем затылочный светодиод
      ADCSRA = 0b11001110;  // включаем ацп после сна
        
      switch (Mode) {             // выбор режима реакции на кнопку
        case 0: w++;  break;      // переключаем режим на спупень Выше  / ниже
        case 1:	Sleep = 1; break; // идем засыпать
        case 2: Mode = 0; break;  // после просыпания не изменяем уровень мощности
      }

      /*
      w  - текущая яркость 
      0 - { OCR0A = 217; } // самый минимум      15 проц  
      1 - { OCR0A = 153; } // четверть яркости   40 проц
      2 - { OCR0A = 89; }  // половина яркости   65 процентов
      "запас" по яркости должен обеспечивать равномерное свечение по мере разряда аккумулятора
      { OCR0A=0; } // самый яркий режим 255 из 256    99 %
      */
      // зацикливание режимов яркости.
      if( w > 2 ) w = 0;

      // зацикливание режимов работы, на всякий случай
      // if( Mode > 2 ) Mode = 0;

      TimeTick = 0; //сброс таймеров после нажатия кнопки
      buttonReleased = 0;
      lastPushButton = 0;

      if( ++countPush > 6 ) Sleep = 1;
    }

    if( TimeTick >= NO_SWITCH_TIME ) {  // программа подсчета времени после включения,  
      TimeTick = 0;                     // после которого мощность не переключаем а засыпаем
      Mode = 1;
    }

    // Программа засыпания //////////////////////////////////////////////////
    if( Sleep == 1 ) {  
      Sleep = 0;        // сброс, чтобы после просыпания сразу не заснуть
      Mode = 2;         // устанавливаем 2 режим после которого мощность не переключается после включения
      countPush = 0;    // сброс счётчика нажатий кнопки
      lowBattary = 0;   // сброс флага низкого напряжения аккумулятора
      OCR0A = 255;      // ШИМ ставим на ноль
      ADCSRA = 0x00;    // выключаем АЦП
      pinOFF(LED1);     // выключаем затылочный светодиод
      _delay_ms(100);
      sleep_enable();   // разрешение режима сна
      sleep_cpu();      // активация режима сна
    }

    _delay_us(1);			

  }
}
